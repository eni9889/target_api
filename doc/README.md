## Документация по API Таргет@Mail.Ru

API Таргет@Mail.Ru позволяет автоматизировать многие классы задач для
технологичных рекламных агентств и прямых клиентов,
а также позволяет широкому кругу сторонних разработчиков задействовать
возможности сервиса.

### Возможности

Доступ к API позволяет агентствам, рекламным платформам и прямым рекламодателям
автоматизировать управление рекламными кампаниями в сервисе Таргет.

Функциональность API полностью соответствует возможностям интерфейса Таргета.
В частности, через API можно создавать и редактировать рекламные кампании и
объявления, управлять их статусом — запускать, останавливать, архивировать.
Через программный интерфейс можно получать информацию о показателях и состоянии
каждого объявления, вплоть до причины отказа в случае, если баннер не прошел
модерацию.

Через API доступны все виды таргетингов, которые предлагает сервис. Протокол
позволяет выбрать аудиторию по площадкам, полу, возрасту, географии, истории
платежей и потребления игр, интересам, дням рождения и некоторым другим
факторам.

Кроме того, при помощи API можно вносить изменения в общие настройки кампании —
например, выбирать модель оплаты за показы или переходы, настраивать лимиты
бюджета и интенсивность трансляции объявлений кампании. Также в API доступен
выбор аукционных стратегий, которые определяют участие баннеров в аукционе.

### Типовые примеры использования

1. Автоматизированное управление ставками по собственным стратегиям. Например,
   единая ставка сразу на группу кампаний.
2. Пакетное редактирование объявлений, например, замена «скидка 30%» на
   «скидака 50%».
3. Разработка платформы управления таргетированной рекламой.

### Устройство

API реализован в виде набора «[ресурсов](/doc/api/detailed/#resources)»
(объектов предметной области) и «методов» (операций над ресурсами), что в
некоторой степени соответствует REST-идеологии. Основным отличием является то,
что многие методы позволяют оперировать ресурсами со сложной структурой,
включающей в себя другие ресурсы с произвольным уровнем вложенности или списки
других ресурсов. Многие методы также поддерживают операции над несколькими
ресурсами одного типа.

Каждый ресурс имеет один или несколько типов URL-адресов. Различные операции
над ресурсом реализованы в виде различных методов протокола HTTP. Например,
получение списка рекламных кампаний:

    GET /api/v1/campaigns.json

Создание кампании:

    POST /api/v1/campaigns.json

Получение параметров конкретной кампании:

    GET /api/v1/campaigns/1.json

Для подавляющего большинства методов входные и выходные данные представлены в
формате JSON. Соответственно, HTTP-запросы и ответы имеют тип
`application/json`. Для GET или DELETE запросов, не имеющих тела, тип
указывать необязательно.

Для валидации входных и генерации выходных данных для каждого ресурса описана
одна или несколько «[структур данных](/doc/api/detailed/#objects)». В описании
каждого метода указано, какими структурами он оперирует.

#### Аутентификация

Для аутентификации API использует механизм проверки подписи запросов. Каждый
запрос к API должен быть подписан секретным ключом (`private_key`), который
генерируется по запросу от пользователя или агентства на
[target.help@corp.mail.ru](mailto:target.help@corp.mail.ru). Вместе с
секретным ключом также выдаётся идентификатор доступа к API (`access_id`),
который передаётся в запросах в открытом виде.

Общаяя последовательность действий для получения подписи:

1. Получение строки для подписи путём конкатенации названия HTTP-метода
(`GET`, `POST` и т.д.), полного URL-адреса API-метода (с указанием протокола,
имени хоста, но без GET-параметров) и тела запроса (в случае GET-запроса
используется пустая строка):

        request_method&urlencode(request_url)&urlencode(request_body)

    В качестве разделителя при конкатенации используется символ амперсанда (`&`).
URL-адрес и тело запроса перед конкатенацией должны быть закодированы
посредством urlencode-преобразования. API использует тот вариант
преобразования, в котором пробел заменяется на `%20` (т.н. percent-encoding).
Пример:

        signed_string = GET&https%3A%2F%2Ftarget-sandbox.mail.ru%2Fapi%2Fv1%2Fgeo_tree.json&

2. Получение подписи из полученной выше строки с использованием механизма HMAC,
алгоритма SHA1 и секретного ключа, выданного для доступа к API. Далее
полученный результат необходимо преобразовать в кодировку Base64 для передачи
в HTTP-запросе:

    signature = Base64-encode(HMAC-SHA1(signed_string, private_key))

3. Передача подписи в HTTP-запросе осуществляется при помощи HTTP-заголовка
Authorization:

    Authorization: AuthHMAC access_id:signature

Пример получения подписи на языке программирования Python
(CPython версий 2 и 3):

    from binascii import b2a_base64
    from hashlib import sha1
    from hmac import new
    try:
        # For Python 3.0 and later.
        from urllib.parse import quote
    except ImportError:
        # Fall back to Python 2's urllib.
        from urllib import quote

    def get_signature(access_id, private_key, url, method='GET', post_data=None):
        method = method.upper()
        data = dumps(post_data) if post_data else ''
        string = '%s&%s&%s' % (
            method,
            quote(url, safe='~'),
            quote(data, safe='~')
        )
        signature = b2a_base64(
            new(private_key, string.encode(), sha1).digest()
        ).decode().rstrip('\n')
        return 'AuthHMAC %s:%s' % (access_id, signature)

Пример получения подписи на языке программирования PHP:

    function get_signature($access_id, $private_key, $url, $method='GET', $post_data=null)
    {
        $method = strtoupper($method);
        $data = $post_data ? $post_data : '';
        $string = sprintf('%s&%s&%s', $method, rawurlencode($url), rawurlencode($data));
        $signature = base64_encode(hex2bin(hash_hmac('sha1', $string, $private_key)));
        return sprintf('AuthHMAC %s:%s', $access_id, $signature);
    }

*Во второй версии API осуществлён переход на протокол [OAuth2](/doc/api/oauth2).*

#### Базовые типы данных

API оперирует следующим набором базовых типов данных:

Тип данных                        | JSON-представление
--------------------------------- | ------------------------------
Строка (String)                   | ``"value"``
Целое число (Integer)             | ``123``
Десятичная дробь (Decimal)        | ``"1.23"``
Булево значение (Boolean)         | ``true`` или ``false``
Ничего (None)                     | ``null``
Дата (Date)                       | ``"2013-08-18"``, формат ``YYYY-MM-DD``, если не если явно не указан другой
Дата и время (Datetime)           | ``"2013-08-28 16:49:34"``, формат `YYYY-MM-DD HH:MM:SS` если явно не указан другой, временная зона UTC+4, если не указана другая
Список (List)                     | ``["value1", "value2"]``, элементы списка однородны
Объект (Object)                   | ``{"id": 1, "name": "Name"}``, свойства объекта могут быть неоднородны

Сложные типы данных, основанные на базовых, описаны в
[документации по методам и ресурсам](/doc/api/detailed/).

#### Базовые ошибки

Ответы с ошибками имеют стандартные статусы HTTP-ответов.
В теле ответа при этом указана более подробная информация об ошибке в формате
JSON (тип ответа-ошибки — ``application/json``).

* ``400`` — ошибка валидации структуры данных, присланной в запросе;
* ``401`` — отсутствие подписи для осуществления аутентификации или же
    неправильное её значение;
* ``403`` — операция запрещена для аккаунта, чьим секретным ключом был подписан
    запрос;
* ``404`` — запрашиваемый ресурс не найден;
* ``405`` — ресурс не поддерживает данный HTTP-метод;
* ``413`` — тело запроса слишком велико;
* ``429`` — превышение лимита на количество запросов в единицу времени;
* ``500`` — непредвиденная ошибка.

#### Сжатие ответа
Если ваш клиент поддерживает сжатие, в запросе можно передавать заголовок:

    Accept-Encoding: gzip, deflate


#### Лимиты на количество запросов в единицу времени
Сервис ограничивает количество запросов в единицу времени.
Ограничения действуют для промежутков времени, равных секунде, часу и дню.
Ограничения привязаны к календарным периодам времени.
Текущние ограничения можно получить с помощью HTTP заголовков ответа:

    X-RateLimit-RPS-Limit: value     # количество запросов в секунду
    X-RateLimit-Hourly-Limit: value  # количество запросов в час
    X-RateLimit-Daily-Limit: value   # количество запросов в день

Количество запросов, которое можно произвести до окончания периода, можно получить c помощью HTTP заголовков ответа:

    X-RateLimit-RPS-Remaining: value    # сколько запросов можно произвести до окончания текущей секунды
    X-RateLimit-Hourly-Remaining: value # сколько запросов можно произвести до окончания текущего часа
    X-RateLimit-Daily-Remaining: value  # сколько запросов можно произвести до окончания текущего дня

#### Тестирование
Для тестирования работы с API существует отдельный тестовый экземпляр сервиса:
``target-sandbox.mail.ru``. Идентификатор доступа и секретный ключ для работы с
ним отличаются от тех, что используются для доступа к основному сервису.

#### Ссылки
* [Подробная документация по методам и ресурсам](/doc/api/detailed/)
* [Примерные реализации клиентов на разных языках программирования](https://github.com/wreckah/target_api)
* [Получение подписи для аутентификации запросов к API](/doc/api/signature/)

*[HMAC]: Hash-based Message Authentication Code
*[HTTP]: HyperText Transfer Protocol
*[JSON]: JavaScript Object Notation
*[REST]: REpresentational State Transfer
*[SHA1]: Secure Hash Algorithm 1
